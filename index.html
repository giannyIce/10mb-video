<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Precision 9.9 MiB Converter</title>
    <script src="https://unpkg.com/mp4box@0.5.2/dist/mp4box.all.min.js"></script>
    <style>
      body {
        font-family: -apple-system, BlinkMacSystemFont, sans-serif;
        display: grid;
        place-items: center;
        height: 100vh;
        background: #f5f5f7;
        color: #1d1d1f;
        margin: 0;
      }
      .container {
        background: white;
        padding: 40px;
        border-radius: 20px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
        text-align: center;
        width: 400px;
      }
      .drop-zone {
        border: 2px dashed #86868b;
        border-radius: 12px;
        padding: 40px 20px;
        margin: 20px 0;
        transition: 0.2s;
        cursor: pointer;
      }
      .drop-zone:hover {
        border-color: #0071e3;
        background: #fbfbfd;
      }
      h1 {
        font-size: 24px;
        margin-bottom: 10px;
        margin-top: 0;
      }
      button {
        background: #0071e3;
        color: white;
        border: none;
        padding: 12px 24px;
        font-size: 16px;
        border-radius: 99px;
        cursor: pointer;
        display: none;
        margin: 20px auto 0;
      }
      .bar-bg {
        background: #e5e5e5;
        height: 6px;
        border-radius: 3px;
        overflow: hidden;
        margin-top: 20px;
        display: none;
      }
      .bar-fill {
        background: #0071e3;
        height: 100%;
        width: 0%;
        transition: width 0.1s linear;
      }
      .stats {
        font-size: 12px;
        color: #86868b;
        margin-top: 10px;
        min-height: 20px;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>Precision 9.9 MiB</h1>
      <p style="color: #86868b; font-size: 14px">Drag your Mac .mov here</p>

      <div class="drop-zone" id="dropArea">Drop .mov file here</div>

      <div class="bar-bg" id="progressBar">
        <div class="bar-fill" id="progressFill"></div>
      </div>
      <div class="stats" id="statusText">Ready</div>

      <button id="dlBtn">Download MP4</button>
    </div>

    <script>
      const dropArea = document.getElementById("dropArea");
      const statusText = document.getElementById("statusText");
      const progressBar = document.getElementById("progressBar");
      const progressFill = document.getElementById("progressFill");
      const dlBtn = document.getElementById("dlBtn");

      dropArea.ondragover = (e) => {
        e.preventDefault();
        dropArea.style.borderColor = "#0071e3";
      };
      dropArea.ondragleave = () => {
        dropArea.style.borderColor = "#86868b";
      };
      dropArea.ondrop = (e) => {
        e.preventDefault();
        handleFile(e.dataTransfer.files[0]);
      };
      dropArea.onclick = () => {
        const input = document.createElement("input");
        input.type = "file";
        input.accept = "video/*";
        input.onchange = (e) => handleFile(e.target.files[0]);
        input.click();
      };

      async function handleFile(file) {
        if (!file) return;

        dlBtn.style.display = "none";
        progressBar.style.display = "block";
        progressFill.style.width = "0%";
        statusText.innerText = "Initializing Binary Engine...";

        const video = document.createElement("video");
        video.muted = true;
        video.src = URL.createObjectURL(file);

        await new Promise((r) => {
          video.onloadedmetadata = r;
        });
        await new Promise((r) => setTimeout(r, 100));

        const duration = video.duration;
        const srcWidth = video.videoWidth;
        const srcHeight = video.videoHeight;

        // --- 1. TARGETING (BINARY MATH) ---
        // Target Video Stream: 9.8 MiB (Leaving 0.1 MiB safety for headers)
        const targetVideoBytes = 9.8 * 1024 * 1024;

        // Bitrate Calculation
        let budgetBitrate = Math.floor((targetVideoBytes * 8) / duration);
        budgetBitrate = Math.min(budgetBitrate, 60_000_000);

        // Resolution: 1080p limit for reliability (4K allowed if < 30s)
        let maxHeight = 1080;
        if (duration < 30) maxHeight = 2160;

        let targetHeight = Math.min(srcHeight, maxHeight);
        let targetWidth = Math.round((srcWidth / srcHeight) * targetHeight);
        targetWidth = targetWidth + (targetWidth % 2);
        targetHeight = targetHeight + (targetHeight % 2);

        statusText.innerText = `Mode: ${targetWidth}x${targetHeight} @ 30fps`;

        // --- 2. SETUP ---
        const canvas = document.createElement("canvas");
        canvas.width = targetWidth;
        canvas.height = targetHeight;
        const ctx = canvas.getContext("2d", {
          desynchronized: true,
          alpha: false,
        });

        const mp4File = MP4Box.createFile();
        let trackId = null;

        const encoder = new VideoEncoder({
          output: (chunk, meta) => {
            if (trackId === null) {
              trackId = mp4File.addTrack({
                timescale: 1000000,
                width: targetWidth,
                height: targetHeight,
                avcDecoderConfigRecord: meta.decoderConfig.description,
              });
            }
            const buf = new ArrayBuffer(chunk.byteLength);
            chunk.copyTo(buf);
            mp4File.addSample(trackId, buf, {
              duration: chunk.duration ?? 0,
              dts: chunk.timestamp,
              cts: chunk.timestamp,
              is_sync: chunk.type === "key",
            });
          },
          error: (e) => console.error("Encoder Error:", e),
        });

        encoder.configure({
          codec: "avc1.420033",
          width: targetWidth,
          height: targetHeight,
          bitrate: budgetBitrate,
          bitrateMode: "constant",
          framerate: 30,
          hardwareAcceleration: "prefer-hardware",
          latencyMode: "realtime",
        });

        // --- 3. MASTER CONTROL LOOP ---
        video.playbackRate = 4.0;
        await video.play();

        const fps = 30;
        const frameInterval = 1 / fps;
        let currentTimeCursor = 0;
        let frameCount = 0;
        const startTime = performance.now();

        while (currentTimeCursor < duration) {
          // Flow Control (Pause if backed up)
          if (encoder.encodeQueueSize > 5) {
            video.pause();
            await new Promise((r) => setTimeout(r, 10));
            continue;
          }

          // Sync Video
          if (video.currentTime < currentTimeCursor) {
            if (video.paused) await video.play();
            if (currentTimeCursor - video.currentTime > 0.5) {
              video.currentTime = currentTimeCursor;
            }
            await new Promise((r) => setTimeout(r, 1));
            continue;
          }

          // Draw
          ctx.drawImage(video, 0, 0, targetWidth, targetHeight);

          const frame = new VideoFrame(canvas, {
            timestamp: currentTimeCursor * 1000000,
            duration: frameInterval * 1000000,
          });

          // Keyframe Logic
          const keyInterval = budgetBitrate > 10000000 ? 30 : 60;
          encoder.encode(frame, { keyFrame: frameCount % keyInterval === 0 });
          frame.close();

          currentTimeCursor += frameInterval;
          frameCount++;

          const percent = Math.min(100, (currentTimeCursor / duration) * 100);
          progressFill.style.width = `${percent}%`;

          if (frameCount % 10 === 0) await new Promise((r) => setTimeout(r, 0));
        }

        statusText.innerText = "Padding to 9.9 MiB...";
        await encoder.flush();

        const rawBlob = new Blob([mp4File.getBuffer()], { type: "video/mp4" });

        // --- 4. EXACT PADDING (BINARY 1024) ---
        // Target: 9.9 MiB exactly
        const targetTotalBytes = 9.9 * 1024 * 1024; // 10,380,902 bytes
        const paddingNeeded = targetTotalBytes - rawBlob.size;
        let finalBlob = rawBlob;

        if (paddingNeeded > 8) {
          const paddingBuffer = new Uint8Array(paddingNeeded);
          const view = new DataView(paddingBuffer.buffer);
          view.setUint32(0, paddingNeeded, false);
          view.setUint8(4, 0x66); // f
          view.setUint8(5, 0x72); // r
          view.setUint8(6, 0x65); // e
          view.setUint8(7, 0x65); // e
          finalBlob = new Blob([rawBlob, paddingBuffer], { type: "video/mp4" });
        }

        const finalTime = ((performance.now() - startTime) / 1000).toFixed(1);
        // Display size in Binary MB (divide by 1024*1024)
        statusText.innerText = `✅ Done: ${finalTime}s • ${(finalBlob.size / 1024 / 1024).toFixed(2)} MB`;
        progressFill.style.width = "100%";

        dlBtn.style.display = "block";
        dlBtn.innerText = "Download MP4";
        dlBtn.onclick = () => {
          const a = document.createElement("a");
          a.href = URL.createObjectURL(finalBlob);
          a.download = `precise_${Date.now()}.mp4`;
          a.click();
        };
      }
    </script>
  </body>
</html>
