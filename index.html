<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Perfect 9.9MB Converter</title>
    <script src="https://unpkg.com/mp4box@0.5.2/dist/mp4box.all.min.js"></script>
    <style>
      body {
        font-family: -apple-system, BlinkMacSystemFont, sans-serif;
        display: grid;
        place-items: center;
        height: 100vh;
        background: #f5f5f7;
        color: #1d1d1f;
        margin: 0;
      }
      .container {
        background: white;
        padding: 40px;
        border-radius: 20px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
        text-align: center;
        width: 400px;
      }
      .drop-zone {
        border: 2px dashed #86868b;
        border-radius: 12px;
        padding: 40px 20px;
        margin: 20px 0;
        transition: 0.2s;
        cursor: pointer;
      }
      .drop-zone:hover {
        border-color: #0071e3;
        background: #fbfbfd;
      }
      h1 {
        font-size: 24px;
        margin-bottom: 10px;
        margin-top: 0;
      }
      button {
        background: #0071e3;
        color: white;
        border: none;
        padding: 12px 24px;
        font-size: 16px;
        border-radius: 99px;
        cursor: pointer;
        display: none;
        margin: 20px auto 0;
      }
      .bar-bg {
        background: #e5e5e5;
        height: 6px;
        border-radius: 3px;
        overflow: hidden;
        margin-top: 20px;
        display: none;
      }
      .bar-fill {
        background: #0071e3;
        height: 100%;
        width: 0%;
        transition: width 0.1s linear;
      }
      .stats {
        font-size: 12px;
        color: #86868b;
        margin-top: 10px;
        min-height: 20px;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>Perfect 9.9MB Converter</h1>
      <p style="color: #86868b; font-size: 14px">Drag your Mac .mov here</p>

      <div class="drop-zone" id="dropArea">Drop .mov file here</div>

      <div class="bar-bg" id="progressBar">
        <div class="bar-fill" id="progressFill"></div>
      </div>
      <div class="stats" id="statusText">Ready</div>

      <button id="dlBtn">Download MP4</button>
    </div>

    <script>
      const dropArea = document.getElementById("dropArea");
      const statusText = document.getElementById("statusText");
      const progressBar = document.getElementById("progressBar");
      const progressFill = document.getElementById("progressFill");
      const dlBtn = document.getElementById("dlBtn");

      dropArea.ondragover = (e) => {
        e.preventDefault();
        dropArea.style.borderColor = "#0071e3";
      };
      dropArea.ondragleave = () => {
        dropArea.style.borderColor = "#86868b";
      };
      dropArea.ondrop = (e) => {
        e.preventDefault();
        handleFile(e.dataTransfer.files[0]);
      };
      dropArea.onclick = () => {
        const input = document.createElement("input");
        input.type = "file";
        input.accept = "video/*";
        input.onchange = (e) => handleFile(e.target.files[0]);
        input.click();
      };

      async function handleFile(file) {
        if (!file) return;

        dlBtn.style.display = "none";
        progressBar.style.display = "block";
        progressFill.style.width = "0%";
        statusText.innerText = "Analyzing Content...";

        const video = document.createElement("video");
        video.muted = true;
        video.src = URL.createObjectURL(file);

        await new Promise((r) => {
          video.onloadedmetadata = r;
        });
        await new Promise((r) => setTimeout(r, 100));

        const duration = video.duration;
        const srcWidth = video.videoWidth;
        const srcHeight = video.videoHeight;

        // --- 1. TARGETING STRATEGY ---
        // Target 9.5MB for the actual video data.
        // We leave 0.4MB of "breathing room" so we can PAD it to exactly 9.9MB later.
        const targetVideoSize = 9.5 * 1024 * 1024;

        let budgetBitrate = Math.floor((targetVideoSize * 8) / duration);
        // Allow extremely high bitrates (up to 50Mbps) so short videos look perfect
        budgetBitrate = Math.min(budgetBitrate, 50_000_000);

        // --- 2. RESOLUTION (Max Clarity) ---
        // Support up to 4K (Level 5.1). Only downscale if video is long.
        let maxHeight = 2160;
        if (duration > 60) maxHeight = 720;
        else if (duration > 30) maxHeight = 1080;

        let targetHeight = Math.min(srcHeight, maxHeight);
        let targetWidth = Math.round((srcWidth / srcHeight) * targetHeight);

        // Even numbers only
        targetWidth = targetWidth + (targetWidth % 2);
        targetHeight = targetHeight + (targetHeight % 2);

        statusText.innerText = `Encoding: ${targetWidth}x${targetHeight} @ ${(budgetBitrate / 1000000).toFixed(1)} Mbps`;

        const canvas = document.createElement("canvas");
        canvas.width = targetWidth;
        canvas.height = targetHeight;
        const ctx = canvas.getContext("2d", {
          desynchronized: true,
          alpha: false,
        });

        const mp4File = MP4Box.createFile();
        let trackId = null;

        const encoder = new VideoEncoder({
          output: (chunk, meta) => {
            if (trackId === null) {
              trackId = mp4File.addTrack({
                timescale: 1000000,
                width: targetWidth,
                height: targetHeight,
                avcDecoderConfigRecord: meta.decoderConfig.description,
              });
            }
            const buf = new ArrayBuffer(chunk.byteLength);
            chunk.copyTo(buf);
            mp4File.addSample(trackId, buf, {
              duration: chunk.duration ?? 0,
              dts: chunk.timestamp,
              cts: chunk.timestamp,
              is_sync: chunk.type === "key",
            });
          },
          error: (e) => console.error(e),
        });

        encoder.configure({
          codec: "avc1.420033", // Level 5.1 (4K Support)
          width: targetWidth,
          height: targetHeight,
          bitrate: budgetBitrate,
          bitrateMode: "constant",
          framerate: 30,
          hardwareAcceleration: "prefer-hardware",
          latencyMode: "realtime",
        });

        video.playbackRate = 4.0;
        await video.play();

        let frameCount = 0;
        const startTime = performance.now();
        let lastTime = -1;
        let isFinished = false;

        function processFrame(now, metadata) {
          if (isFinished) return;
          if (video.ended || video.paused) {
            finish();
            return;
          }

          if (metadata.mediaTime !== lastTime) {
            lastTime = metadata.mediaTime;
            ctx.drawImage(video, 0, 0, targetWidth, targetHeight);

            if (encoder.encodeQueueSize < 5) {
              const frame = new VideoFrame(canvas, {
                timestamp: metadata.mediaTime * 1000000,
                duration: 33333,
              });

              // Frequent keyframes for clarity
              const keyInterval = budgetBitrate > 10000000 ? 15 : 60;
              encoder.encode(frame, {
                keyFrame: frameCount % keyInterval === 0,
              });
              frame.close();
              frameCount++;
            }
            const percent = Math.min(
              100,
              (metadata.mediaTime / duration) * 100,
            );
            progressFill.style.width = `${percent}%`;
          }
          video.requestVideoFrameCallback(processFrame);
        }

        video.onended = () => {
          if (!isFinished) finish();
        };
        video.requestVideoFrameCallback(processFrame);

        async function finish() {
          if (isFinished) return;
          isFinished = true;
          statusText.innerText = "Applying Size Padding...";

          await encoder.flush();

          // 1. Get the compressed video blob
          const rawBlob = new Blob([mp4File.getBuffer()], {
            type: "video/mp4",
          });

          // 2. CALCULATE PADDING NEEDED
          // We want exactly 9.9 MB (10,380,902 bytes)
          const targetTotalBytes = 9.9 * 1024 * 1024;
          const currentBytes = rawBlob.size;
          const paddingNeeded = targetTotalBytes - currentBytes;

          let finalBlob = rawBlob;

          // Only pad if we are UNDER the limit and need > 8 bytes (min box size)
          if (paddingNeeded > 8) {
            // Create a "free" box
            // 4 bytes size, 4 bytes type ('free'), N bytes zeroes
            const paddingBuffer = new Uint8Array(paddingNeeded);
            const view = new DataView(paddingBuffer.buffer);

            // Write 32-bit Size (Big Endian)
            view.setUint32(0, paddingNeeded, false);

            // Write Type 'free' (0x66726565)
            view.setUint8(4, 0x66); // f
            view.setUint8(5, 0x72); // r
            view.setUint8(6, 0x65); // e
            view.setUint8(7, 0x65); // e

            // The rest is already zeroes (Uint8Array default)

            // Combine: Video + Padding
            finalBlob = new Blob([rawBlob, paddingBuffer], {
              type: "video/mp4",
            });
            console.log(`Padded with ${paddingNeeded} bytes.`);
          }

          const finalTime = ((performance.now() - startTime) / 1000).toFixed(1);

          statusText.innerText = `✅ Perfect Match: ${finalTime}s • ${(finalBlob.size / 1024 / 1024).toFixed(2)} MB`;
          progressFill.style.width = "100%";

          dlBtn.style.display = "block";
          dlBtn.innerText = "Download MP4";
          dlBtn.onclick = () => {
            const a = document.createElement("a");
            a.href = URL.createObjectURL(finalBlob);
            a.download = `perfect_${Date.now()}.mp4`;
            a.click();
          };
        }
      }
    </script>
  </body>
</html>
